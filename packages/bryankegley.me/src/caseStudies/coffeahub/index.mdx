---
title: coffeahub.com
summary: coffeahub.com is an internal application for Coffea Roasterie to streamline business operations and make information from various internal and third-party services more accessible across the organization.
organization: Coffea Roasterie
tags: React.js, Gatsby, GraphQL, MongoDB, Microservices Architecture
---

import CaseStudySection from '../../components/CaseStudySection'
import Quotation from '../../components/Quotation'

<CaseStudySection title="Problem">
Coffea Roasterie is a growing specialty coffee roaster/retailer in the process of opening a fourth café.
Growth causes challenges for many businesses but can present unique challenges for small businesses.
Furthering a geographic presence causes strain to these existing difficulties.
The primary goal of coffeahub.com is to alleviate the challenges a growing small business faces.

Local companies handle growth with the help of many third-party applications that solve immediate pain-points (sales,
scheduling, POS, etc.). However, over time this leads to redundant data points, increased labor and data entry errors,
and difficulty finding crucial business operations. Coffea Roasterie needed a single platform to consolidate
information across the organization so that they could continue to push forward in the specialty coffee industry.

</CaseStudySection>

<CaseStudySection title="Why Microservices?">
As I would be the sole developer on the project, I needed to settle on architecture that would allow flexibility and extensibility as the scope of the project grew.
It was also necessary to design the project in such a way that isolated modules could be quickly designed and executed while hiding implementation details under accessible APIs.
Often there were going to be long periods of time between development cycles which meant that large features of the application needed to be quickly comprehended to continue working.

Besides the many other benefits of a microservices architecture I determined that this best suited the specific development requirements for coffeahub.
Being able to build, test, and maintain isolated units of the backend of the application lowered the cognitive startup time
for working on the project. Implementation details for each of the various services (authentication, Shopify, Square,
When I Work, etc.) weren’t important as the project continued. This made adding additional services trivial as the scope of the project increased over time.

Furthermore, the decision to adopt microservices made the project future-proof as scaling could be done on an individual service as required.
Initially, a single machine would handle the load but adding additional machines would be as easy as updating a connection string.

</CaseStudySection>

<CaseStudySection title="Building a GraphQL API">
Utilizing GraphQL for the project was one of the best decisions for speed and maintainability. The self-documenting
nature of a GraphQL API made it accessible as a solo developer while developing on different parts of the stack. Like
the decision to use microservices, utilizing GraphQL allowed the frontend to not be concerned with the implementation
of data-fetching across various APIs which sped development significantly.

</CaseStudySection>

<Quotation>"The ease of data-fetching from multiple services with GraphQL sped development significantly."</Quotation>

<CaseStudySection>
Authentication proved to be one of the biggest challenges in building the endpoint.
The client authenticated with sessions to the API Gateway however, as I was learning microservice orchestration during the project I had a number of failed attempts at authenticating to the various services.
The final implementation utilized an Authorization header on requests from the API Gateway to other services.

While implementing GraphQL in a microservices architecture caused some hiccups the benefits of doing so far outweighed the pains both in terms of productivity and future extensibility.

</CaseStudySection>
